"use strict";
// Copyright IBM Corp. 2017,2018. All Rights Reserved.
// Node module: @loopback/rest
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const openapi_v3_1 = require("@loopback/openapi-v3");
const openapi_v3_types_1 = require("@loopback/openapi-v3-types");
const debugModule = require("debug");
const HttpErrors = require("http-errors");
const parseUrl = require("parseurl");
const qs_1 = require("qs");
const util_1 = require("util");
const coerce_parameter_1 = require("./coercion/coerce-parameter");
const index_1 = require("./index");
const request_body_validator_1 = require("./validation/request-body.validator");
const debug = debugModule('loopback:rest:parser');
exports.QUERY_NOT_PARSED = {};
Object.freeze(exports.QUERY_NOT_PARSED);
const parseJsonBody = util_1.promisify(require('body/json'));
/**
 * Get the content-type header value from the request
 * @param req Http request
 */
function getContentType(req) {
    const val = req.headers['content-type'];
    if (typeof val === 'string') {
        return val;
    }
    else if (Array.isArray(val)) {
        // Assume only one value is present
        return val[0];
    }
    return undefined;
}
/**
 * Parses the request to derive arguments to be passed in for the Application
 * controller method
 *
 * @param request Incoming HTTP request
 * @param route Resolved Route
 */
async function parseOperationArgs(request, route) {
    debug('Parsing operation arguments for route %s', route.describe());
    const operationSpec = route.spec;
    const pathParams = route.pathParams;
    const body = await loadRequestBodyIfNeeded(operationSpec, request);
    return buildOperationArguments(operationSpec, request, pathParams, body, route.schemas);
}
exports.parseOperationArgs = parseOperationArgs;
async function loadRequestBodyIfNeeded(operationSpec, request) {
    if (!operationSpec.requestBody)
        return Promise.resolve();
    const contentType = getContentType(request);
    debug('Loading request body with content type %j', contentType);
    if (contentType && !/json/.test(contentType)) {
        throw new HttpErrors.UnsupportedMediaType(`Content-type ${contentType} is not supported.`);
    }
    return await parseJsonBody(request).catch((err) => {
        debug('Cannot parse request body %j', err);
        err.statusCode = 400;
        throw err;
    });
}
function buildOperationArguments(operationSpec, request, pathParams, body, globalSchemas) {
    let requestBodyIndex = -1;
    if (operationSpec.requestBody) {
        // the type of `operationSpec.requestBody` could be `RequestBodyObject`
        // or `ReferenceObject`, resolving a `$ref` value is not supported yet.
        if (openapi_v3_types_1.isReferenceObject(operationSpec.requestBody)) {
            throw new Error('$ref requestBody is not supported yet.');
        }
        const i = operationSpec.requestBody[openapi_v3_1.REQUEST_BODY_INDEX];
        requestBodyIndex = i ? i : 0;
    }
    const paramArgs = [];
    for (const paramSpec of operationSpec.parameters || []) {
        if (openapi_v3_types_1.isReferenceObject(paramSpec)) {
            // TODO(bajtos) implement $ref parameters
            // See https://github.com/strongloop/loopback-next/issues/435
            throw new Error('$ref parameters are not supported yet.');
        }
        const spec = paramSpec;
        const rawValue = getParamFromRequest(spec, request, pathParams);
        const coercedValue = coerce_parameter_1.coerceParameter(rawValue, spec);
        paramArgs.push(coercedValue);
    }
    debug('Validating request body - value %j', body);
    request_body_validator_1.validateRequestBody(body, operationSpec.requestBody, globalSchemas);
    if (requestBodyIndex > -1)
        paramArgs.splice(requestBodyIndex, 0, body);
    return paramArgs;
}
function getParamFromRequest(spec, request, pathParams) {
    switch (spec.in) {
        case 'query':
            ensureRequestQueryWasParsed(request);
            return request.query[spec.name];
        case 'path':
            return pathParams[spec.name];
        case 'header':
            // @jannyhou TBD: check edge cases
            return request.headers[spec.name.toLowerCase()];
            break;
        // TODO(jannyhou) to support `cookie`,
        // see issue https://github.com/strongloop/loopback-next/issues/997
        default:
            throw index_1.RestHttpErrors.invalidParamLocation(spec.in);
    }
}
function ensureRequestQueryWasParsed(request) {
    if (request.query && request.query !== exports.QUERY_NOT_PARSED)
        return;
    const input = parseUrl(request).query;
    if (input && typeof input === 'string') {
        request.query = qs_1.parse(input);
    }
    else {
        request.query = {};
    }
    debug('Parsed request query: ', request.query);
}
//# sourceMappingURL=parser.js.map