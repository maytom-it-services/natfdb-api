"use strict";
// Copyright IBM Corp. 2017,2018. All Rights Reserved.
// Node module: @loopback/example-todo
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const constraint_utils_1 = require("./constraint-utils");
const context_1 = require("@loopback/context");
exports.Getter = context_1.Getter;
const errors_1 = require("../errors");
class DefaultHasManyRepository {
    /**
     * Constructor of DefaultHasManyEntityCrudRepository
     * @param getTargetRepository the getter of the related target model repository instance
     * @param constraint the key value pair representing foreign key name to constrain
     * the target repository instance
     */
    constructor(getTargetRepository, constraint) {
        this.getTargetRepository = getTargetRepository;
        this.constraint = constraint;
    }
    async create(targetModelData, options) {
        const targetRepository = await this.getTargetRepository();
        return targetRepository.create(constraint_utils_1.constrainDataObject(targetModelData, this.constraint), options);
    }
    async find(filter, options) {
        const targetRepository = await this.getTargetRepository();
        return targetRepository.find(constraint_utils_1.constrainFilter(filter, this.constraint), options);
    }
    async delete(where, options) {
        const targetRepository = await this.getTargetRepository();
        return targetRepository.deleteAll(constraint_utils_1.constrainWhere(where, this.constraint), options);
    }
    async patch(dataObject, where, options) {
        const targetRepository = await this.getTargetRepository();
        return targetRepository.updateAll(constraint_utils_1.constrainDataObject(dataObject, this.constraint), constraint_utils_1.constrainWhere(where, this.constraint), options);
    }
}
exports.DefaultHasManyRepository = DefaultHasManyRepository;
class DefaultBelongsToRepository {
    /**
     * Constructor of DefaultBelongsToEntityCrudRepository
     * @param getTargetRepository the getter of the related target model repository instance
     * @param constraint the key value pair representing foreign key name to constrain
     * the target repository instance
     */
    constructor(getTargetRepository, constraint) {
        this.getTargetRepository = getTargetRepository;
        this.constraint = constraint;
    }
    async get(options) {
        const targetRepo = await this.getTargetRepository();
        const result = await targetRepo.find(constraint_utils_1.constrainFilter(undefined, this.constraint), options);
        if (!result.length) {
            // We don't have a direct access to the foreign key value here :(
            const id = 'constraint ' + JSON.stringify(this.constraint);
            throw new errors_1.EntityNotFoundError(targetRepo.entityClass, id);
        }
        return result[0];
    }
}
exports.DefaultBelongsToRepository = DefaultBelongsToRepository;
//# sourceMappingURL=relation.repository.js.map