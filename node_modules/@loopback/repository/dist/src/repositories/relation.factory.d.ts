import { BelongsToDefinition, HasManyDefinition } from '../decorators/relation.decorator';
import { Entity } from '../model';
import { Getter, HasManyRepository } from './relation.repository';
import { EntityCrudRepository } from './repository';
export declare type HasManyRepositoryFactory<Target extends Entity, ForeignKeyType> = (fkValue: ForeignKeyType) => HasManyRepository<Target>;
export declare type BelongsToAccessor<Target extends Entity, SourceId> = (sourceId: SourceId) => Promise<Target>;
/**
 * Enforces a constraint on a repository based on a relationship contract
 * between models. For example, if a Customer model is related to an Order model
 * via a HasMany relation, then, the relational repository returned by the
 * factory function would be constrained by a Customer model instance's id(s).
 *
 * @param relationMeta The relation metadata used to describe the
 * relationship and determine how to apply the constraint.
 * @param targetRepo The repository which represents the target model of a
 * relation attached to a datasource.
 * @returns The factory function which accepts a foreign key value to constrain
 * the given target repository
 */
export declare function createHasManyRepositoryFactory<Target extends Entity, TargetID, ForeignKeyType>(relationMetadata: HasManyDefinition, targetRepositoryGetter: Getter<EntityCrudRepository<Target, TargetID>>): HasManyRepositoryFactory<Target, ForeignKeyType>;
/**
 * Enforces a BelongsTo constraint on a repository
 */
export declare function createBelongsToAccessor<Target extends Entity, TargetId, Source extends Entity, SourceId>(belongsToMetadata: BelongsToDefinition, targetRepoGetter: Getter<EntityCrudRepository<Target, TargetId>>, sourceRepository: EntityCrudRepository<Source, SourceId>): BelongsToAccessor<Target, SourceId>;
