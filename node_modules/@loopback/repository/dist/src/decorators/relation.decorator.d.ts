import { Entity, EntityResolver, Model, RelationDefinitionMap } from '../model';
import { TypeResolver } from '../type-resolver';
export declare enum RelationType {
    belongsTo = "belongsTo",
    hasOne = "hasOne",
    hasMany = "hasMany",
    embedsOne = "embedsOne",
    embedsMany = "embedsMany",
    referencesOne = "referencesOne",
    referencesMany = "referencesMany"
}
export declare const RELATIONS_KEY = "loopback:relations";
export interface RelationDefinitionBase {
    /**
     * The type of the relation, must be one of RelationType values.
     */
    type: RelationType;
    /**
     * The relation name, typically matching the name of the accessor property
     * defined on the source model. For example "orders" or "customer".
     */
    name: string;
    /**
     * The source model of this relation.
     *
     * E.g. when a Customer has many Order instances, then Customer is the source.
     */
    source: typeof Entity;
    /**
     * The target model of this relation.
     *
     * E.g. when a Customer has many Order instances, then Order is the target.
     */
    target: TypeResolver<Entity, typeof Entity>;
}
export interface HasManyDefinition extends RelationDefinitionBase {
    type: RelationType.hasMany;
    /**
     * The foreign key used by the target model.
     *
     * E.g. when a Customer has many Order instances, then keyTo is "customerId".
     * Note that "customerId" is the default FK assumed by the framework, users
     * can provide a custom FK name by setting "keyTo".
     */
    keyTo?: string;
}
export interface BelongsToDefinition extends RelationDefinitionBase {
    type: RelationType.belongsTo;
    keyFrom: string;
    keyTo?: string;
}
export declare type RelationMetadata = HasManyDefinition | BelongsToDefinition | RelationDefinitionBase;
/**
 * Decorator for relations
 * @param definition
 * @returns {(target:any, key:string)}
 */
export declare function relation(definition?: Object): PropertyDecorator;
/**
 * Decorator for belongsTo
 * @param definition
 * @returns {(target: Object, key:string)}
 */
export declare function belongsTo<T extends Entity>(targetResolver: EntityResolver<T>, definition?: Partial<BelongsToDefinition>): (decoratedTarget: Entity, decoratedKey: string) => void;
/**
 * Decorator for hasOne
 * @param definition
 * @returns {(target:any, key:string)}
 */
export declare function hasOne(definition?: Object): PropertyDecorator;
/**
 * Decorator for hasMany
 * Calls property.array decorator underneath the hood and infers foreign key
 * name from target model name unless explicitly specified
 * @param targetResolver Target model for hasMany relation
 * @param definition Optional metadata for setting up hasMany relation
 * @returns {(target:any, key:string)}
 */
export declare function hasMany<T extends Entity>(targetResolver: EntityResolver<T>, definition?: Partial<HasManyDefinition>): (decoratedTarget: Object, key: string) => void;
/**
 * Decorator for embedsOne
 * @param definition
 * @returns {(target:any, key:string)}
 */
export declare function embedsOne(definition?: Object): PropertyDecorator;
/**
 * Decorator for embedsMany
 * @param definition
 * @returns {(target:any, key:string)}
 */
export declare function embedsMany(definition?: Object): PropertyDecorator;
/**
 * Decorator for referencesOne
 * @param definition
 * @returns {(target:any, key:string)}
 */
export declare function referencesOne(definition?: Object): PropertyDecorator;
/**
 * Decorator for referencesMany
 * @param definition
 * @returns {(target:any, key:string)}
 */
export declare function referencesMany(definition?: Object): PropertyDecorator;
/**
 * Get metadata of all relations defined on a given model class.
 *
 * @param modelCtor The model class (the constructor function).
 * @return
 */
export declare function getModelRelations(modelCtor: typeof Model): RelationDefinitionMap;
