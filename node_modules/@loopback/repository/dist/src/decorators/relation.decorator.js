"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/repository
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("@loopback/context");
const model_decorator_1 = require("./model.decorator");
var RelationType;
(function (RelationType) {
    RelationType["belongsTo"] = "belongsTo";
    RelationType["hasOne"] = "hasOne";
    RelationType["hasMany"] = "hasMany";
    RelationType["embedsOne"] = "embedsOne";
    RelationType["embedsMany"] = "embedsMany";
    RelationType["referencesOne"] = "referencesOne";
    RelationType["referencesMany"] = "referencesMany";
})(RelationType = exports.RelationType || (exports.RelationType = {}));
exports.RELATIONS_KEY = 'loopback:relations';
/**
 * Decorator for relations
 * @param definition
 * @returns {(target:any, key:string)}
 */
function relation(definition) {
    // Apply relation definition to the model class
    return context_1.PropertyDecoratorFactory.createDecorator(exports.RELATIONS_KEY, definition);
}
exports.relation = relation;
/**
 * Decorator for belongsTo
 * @param definition
 * @returns {(target: Object, key:string)}
 */
function belongsTo(targetResolver, definition) {
    return function (decoratedTarget, decoratedKey) {
        const propMeta = {
            type: context_1.MetadataInspector.getDesignTypeForProperty(decoratedTarget, decoratedKey),
        };
        model_decorator_1.property(propMeta)(decoratedTarget, decoratedKey);
        // @belongsTo() is typically decorating the foreign key property,
        // e.g. customerId. We need to strip the trailing "Id" suffix from the name.
        const relationName = decoratedKey.replace(/Id$/, '');
        const meta = Object.assign(
        // default values, can be customized by the caller
        {
            keyFrom: decoratedKey,
        }, 
        // properties provided by the caller
        definition, 
        // properties enforced by the decorator
        {
            type: RelationType.belongsTo,
            name: relationName,
            source: decoratedTarget.constructor,
            target: targetResolver,
        });
        relation(meta)(decoratedTarget, decoratedKey);
    };
}
exports.belongsTo = belongsTo;
/**
 * Decorator for hasOne
 * @param definition
 * @returns {(target:any, key:string)}
 */
function hasOne(definition) {
    const rel = Object.assign({ type: RelationType.hasOne }, definition);
    return context_1.PropertyDecoratorFactory.createDecorator(exports.RELATIONS_KEY, rel);
}
exports.hasOne = hasOne;
/**
 * Decorator for hasMany
 * Calls property.array decorator underneath the hood and infers foreign key
 * name from target model name unless explicitly specified
 * @param targetResolver Target model for hasMany relation
 * @param definition Optional metadata for setting up hasMany relation
 * @returns {(target:any, key:string)}
 */
function hasMany(targetResolver, definition) {
    return function (decoratedTarget, key) {
        model_decorator_1.property.array(targetResolver)(decoratedTarget, key);
        const meta = Object.assign(
        // default values, can be customized by the caller
        {}, 
        // properties provided by the caller
        definition, 
        // properties enforced by the decorator
        {
            type: RelationType.hasMany,
            name: key,
            source: decoratedTarget.constructor,
            target: targetResolver,
        });
        relation(meta)(decoratedTarget, key);
    };
}
exports.hasMany = hasMany;
/**
 * Decorator for embedsOne
 * @param definition
 * @returns {(target:any, key:string)}
 */
function embedsOne(definition) {
    const rel = Object.assign({ type: RelationType.embedsOne }, definition);
    return context_1.PropertyDecoratorFactory.createDecorator(exports.RELATIONS_KEY, rel);
}
exports.embedsOne = embedsOne;
/**
 * Decorator for embedsMany
 * @param definition
 * @returns {(target:any, key:string)}
 */
function embedsMany(definition) {
    const rel = Object.assign({ type: RelationType.embedsMany }, definition);
    return context_1.PropertyDecoratorFactory.createDecorator(exports.RELATIONS_KEY, rel);
}
exports.embedsMany = embedsMany;
/**
 * Decorator for referencesOne
 * @param definition
 * @returns {(target:any, key:string)}
 */
function referencesOne(definition) {
    const rel = Object.assign({ type: RelationType.referencesOne }, definition);
    return context_1.PropertyDecoratorFactory.createDecorator(exports.RELATIONS_KEY, rel);
}
exports.referencesOne = referencesOne;
/**
 * Decorator for referencesMany
 * @param definition
 * @returns {(target:any, key:string)}
 */
function referencesMany(definition) {
    const rel = Object.assign({ type: RelationType.referencesMany }, definition);
    return context_1.PropertyDecoratorFactory.createDecorator(exports.RELATIONS_KEY, rel);
}
exports.referencesMany = referencesMany;
/**
 * Get metadata of all relations defined on a given model class.
 *
 * @param modelCtor The model class (the constructor function).
 * @return
 */
function getModelRelations(modelCtor) {
    return (modelCtor.definition && modelCtor.definition.relations) || {};
}
exports.getModelRelations = getModelRelations;
//# sourceMappingURL=relation.decorator.js.map